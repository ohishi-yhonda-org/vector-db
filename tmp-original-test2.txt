        })
      })

      // setTimeoutをモックしてすぐに実行
      vi.spyOn(global, 'setTimeout').mockImplementation((fn: any) => {
        fn()
        return 0 as any
      })

      await expect(
        vectorManager.createVectorAsync('Test text')
      ).rejects.toThrow('Failed to save vector: Save error')
    })

    it('should handle vector workflow timeout', async () => {
      // setTimeoutをモックしてすぐに実行
      vi.spyOn(global, 'setTimeout').mockImplementation((fn: any) => {
        fn()
        return 0 as any
      })

      // Embedding workflow succeeds immediately
      mockEnv.EMBEDDINGS_WORKFLOW.get.mockResolvedValueOnce({
        status: vi.fn().mockResolvedValue({
          status: 'complete',
          output: {
            success: true,
            embedding: [0.1, 0.2, 0.3],
            model: '@cf/baai/bge-base-en-v1.5'
          }
        })
      })

      // Vector workflow always returns running status
      mockEnv.VECTOR_OPERATIONS_WORKFLOW.get.mockResolvedValueOnce({
        status: vi.fn().mockResolvedValue({
          status: 'running'
        })
      })

      // After timeout, vectorResult is null, so it throws 'Unknown error'
      await expect(
        vectorManager.createVectorAsync('Test text')
      ).rejects.toThrow('Failed to save vector: Unknown error')
    })

    it('should handle null vector result', async () => {
      // Embedding workflow succeeds
      mockEnv.EMBEDDINGS_WORKFLOW.get.mockResolvedValueOnce({
        status: vi.fn().mockResolvedValue({
          status: 'complete',
          output: {
            success: true,
            embedding: [0.1, 0.2, 0.3],
            model: '@cf/baai/bge-base-en-v1.5'
          }
        })
      })

      // Vector workflow returns null output
      mockEnv.VECTOR_OPERATIONS_WORKFLOW.get.mockResolvedValueOnce({
        status: vi.fn().mockResolvedValue({
          status: 'complete',
          output: null
        })
      })

      // setTimeoutをモックしてすぐに実行
      vi.spyOn(global, 'setTimeout').mockImplementation((fn: any) => {
        fn()
        return 0 as any
      })

      await expect(
        vectorManager.createVectorAsync('Test text')
      ).rejects.toThrow('Failed to save vector: Unknown error')
    })
  })

  describe('deleteVectorsAsync', () => {
    it('should delete vectors asynchronously', async () => {
      const vectorIds = ['vec-1', 'vec-2']
      const result = await vectorManager.deleteVectorsAsync(vectorIds)

      expect(result).toMatchObject({
        jobId: expect.stringContaining('vec_delete_'),
        status: 'processing'
      })
      expect(mockEnv.VECTOR_OPERATIONS_WORKFLOW.create).toHaveBeenCalledWith({
        id: result.jobId,
        params: {
          type: 'delete',
          vectorIds
        }
      })
    })
  })

  describe('Job Management', () => {
    it('should get job status', async () => {
      await vectorManager.deleteVectorsAsync(['vec-1'])
