      await vectorManager.deleteVectorsAsync(['vec-1'])
      const jobs = await vectorManager.getAllJobs()
      const jobId = jobs[0].id

      const job = await vectorManager.getJobStatus(jobId)
      expect(job).toBeDefined()
      expect(job?.type).toBe('delete')
    })

    it('should get all jobs', async () => {
      await vectorManager.deleteVectorsAsync(['vec-1'])
      await vectorManager.deleteVectorsAsync(['vec-2'])

      const jobs = await vectorManager.getAllJobs()
      expect(jobs).toHaveLength(2)
    })

    it('should cleanup old completed jobs', async () => {
      const oldDate = new Date(Date.now() - 25 * 60 * 60 * 1000).toISOString()
      const recentDate = new Date().toISOString()

      vectorManager.setState({
        ...vectorManager.state,
        vectorJobs: {
          'old-job': {
            id: 'old-job',
            type: 'delete',
            status: 'completed',
            createdAt: oldDate
          },
          'recent-job': {
            id: 'recent-job',
            type: 'delete',
            status: 'completed',
            createdAt: recentDate
          },
          'old-pending': {
            id: 'old-pending',
            type: 'delete',
            status: 'pending',
            createdAt: oldDate
          }
        }
      })

      const deletedCount = await vectorManager.cleanupOldJobs(24)
      expect(deletedCount).toBe(1)

      const remainingJobs = await vectorManager.getAllJobs()
      expect(remainingJobs).toHaveLength(2)
    })

    it('should return 0 when no jobs to cleanup', async () => {
      const deletedCount = await vectorManager.cleanupOldJobs(24)
      expect(deletedCount).toBe(0)
    })

    it('should use default parameter when not specified', async () => {
      const deletedCount = await vectorManager.cleanupOldJobs()
      expect(deletedCount).toBe(0)
    })
  })

  describe('File Processing', () => {
    it('should process file asynchronously', async () => {
      const result = await vectorManager.processFileAsync(
        'file content',
        'test.txt',
        'text/plain',
        1024,
        'files',
        { source: 'upload' }
      )

      expect(result).toMatchObject({
        jobId: expect.stringContaining('file_process_'),
        status: 'processing'
      })
      expect(mockEnv.FILE_PROCESSING_WORKFLOW.create).toHaveBeenCalled()
    })

    it('should get file processing job status', async () => {
      const result = await vectorManager.processFileAsync(
        'content',
        'test.txt',
        'text/plain',
        100
      )

      const job = await vectorManager.getFileProcessingJob(result.jobId)
      expect(job).toBeDefined()
      expect(job?.fileName).toBe('test.txt')
    })

    it('should get all file processing jobs', async () => {
      await vectorManager.processFileAsync('content1', 'file1.txt', 'text/plain', 100)
      await vectorManager.processFileAsync('content2', 'file2.txt', 'text/plain', 200)

      const jobs = await vectorManager.getAllFileProcessingJobs()
      expect(jobs).toHaveLength(2)
    })
